#!/bin/bash
version='2.0.0'
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die() {
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}

begins_with_short_option() {
    local first_option all_short_options
    all_short_options='fjh'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

icloud_path=~/Library/Mobile\ Documents/com~apple~Numbers/Documents
csv_path=$PWD/Output/MainCSV/
output_path=$PWD/Output

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_import_path=
_arg_jira="-"
_arg_dry_run="off"
_arg_silent="off"
_arg_output=

_script_path=$(perl -MCwd -e 'print Cwd::abs_path shift')
_script_name="$0"
_branch="master"
_args=( "$@" )

print_help () {

}

handle_passed_args_count () {
    _required_args_string="'project', 'platform' and 'business-unit'"
    test ${#_positionals[@]} -ge 3 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 3 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
    test ${#_positionals[@]} -le 3 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 3 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args () {
    _positional_names=('_arg_project' '_arg_platform' '_arg_business_unit' )

    for (( ii = 0; ii < ${#_positionals[@]}; ii++))
    do
        eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
    done
}

log() {
  if [ ! $_arg_silent == "on" ]; then
    echo $1
  fi
}

self_update() {
    cd $_script_path

    echo "Fetching repo..."
    git fetch

    upstream=${1:-'origin/master'}
    local=$(git rev-parse @{0})
    remote=$(git rev-parse "$upstream")
    base=$(git merge-base @{0} "$upstream")

    if test $local = $remote ; then
        :
    elif test $local = $base ; then
        echo "Found a new version, updating..."
        git pull
        echo "Running the new version..."
        exec "$_script_name" "${_args[@]}"

        # Now exit this old instance
        exit 1
    elif test $remote = $base ; then
        :
    else
        :
    fi
}

reset_output() {
    # Create main CSV directory if not exist
    mkdir -p $output_path

    # Clear all output first
    rm -rf $output_path/*
}

export_to_android() {
    reset_output

    # Convert number to csv
    osascript ./spreadsheet_to_csv.scpt "$icloud_path/$_arg_project.numbers" "$csv_path"

    # Select BU
    python3 csv_filter_by_bu.py $csv_path $output_path $_arg_business_unit 2 $_arg_silent $_arg_dry_run

    # Combine CSV
    cat $output_path/FilteredCSV/*.csv > $output_path/merged.csv

    # Change platform specific and apply template
    python3 platform_extractor.py $output_path/merged.csv $output_path/template.info $output_path/merged_extracted.csv android $_arg_silent $_arg_dry_run

    # Generate String Files
    python3 localizer_caller.py $output_path $output_path/Android android $_arg_silent $_arg_dry_run
}

export_to_ios() {
    reset_output
    
    # Convert number to csv
    osascript ./spreadsheet_to_csv.scpt "$icloud_path/$_arg_project.numbers" "$csv_path"

    # Select BU
    python3 csv_filter_by_bu.py $csv_path $output_path $_arg_business_unit 1 $_arg_silent $_arg_dry_run

    # Combine CSV
    cat $output_path/FilteredCSV/*.csv > $output_path/merged.csv

    # Change platform specific and apply template
    python3 platform_extractor.py $output_path/merged.csv $output_path/template.info $output_path/merged_extracted.csv ios $_arg_silent $_arg_dry_run

    # Generate String Files
    python3 localizer_caller.py $output_path $output_path/iOS ios $_arg_silent $_arg_dry_run
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

if [ ! "$_arg_platform" ]; then
    log 'ERROR: cannot perform command "platform" required."'
    exit 1
fi 

if [ ! "$_arg_project" ]; then
    log 'ERROR: cannot perform command "project" required."'
    exit 1
fi 

if [ ! "$_arg_business_unit" ]; then
    log 'ERROR: cannot perform command "business-unit" required."'
    exit 1
fi 

# Check iCloud Numbers file exists.
if [ ! -e "$icloud_path/$_arg_project.numbers" ]; then
    log 'ERROR: cannot find "'$_arg_project.numbers'" in your local iCloud.'
    exit 1 
fi

if ! [ -x "$(command -v python3)" ]; then
    log 'ERROR: python3 is not installed. please download Latest Python 3 Release here: https://www.python.org/downloads/mac-osx/'
    exit 1
fi

python3 -c "import sys, pkgutil; sys.exit(0 if pkgutil.find_loader('openpyxl') and pkgutil.find_loader('appscript') else 1)"
result=$?

if [ ! $result == 0 ]; then
    log 'ERROR: required libraries in python 3 not found in pip please install those libraries first. To install type'
    log '> "python3 -m pip install openpyxl" and/or'
    log '> "python3 -m pip install appscript"'
    exit 1
fi

case $_arg_platform in 
    ios | iOS)
        export_to_ios
        if [ -z "$_arg_output" ]
        then
            open $output_path/iOS
        else
            cp -r $output_path/iOS/* $_arg_output
            log "Papyrus successfully exported."
        fi
        ;;
    and | android | Android)
        export_to_android
        if [ -z "$_arg_output" ]
        then
            open $output_path/Android
        else
            cp -r $output_path/Android/* $_arg_output
            log "Papyrus successfully exported."
        fi
        ;;
    *)
        log "ERROR: unknown platform \"$_arg_platform\""
        exit 1
        ;;
esac
